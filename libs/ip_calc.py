import re


class IPCalc(object):
    def __init__(self, logger=None):
        self.logger = logger
        self.details = {}

        self.init()

    def init(self):
        if not self.logger:
            from utils.helpers import setup_logger
            self.logger = setup_logger(name='IPCalc')

    def get_info(self, ip, simple=True):
        """
        Get Information IP address from IP with or without CIDR
        @param ip: string (E.g 192.168.0.1 or 192.168.0.1/24)
        @param simple: boolean (If True will return as simple mode)
        @return: dict
        """
        ip_address, prefix, cidr = self.parse_ip(ip)
        if not ip_address:
            self.logger.error('Failed to get info IP Address')
            return

        details = {
            'simple': simple,
            'source': ip,
        }

        ip_address_bin = self.ip_to_bin(ip_address)
        ip_class = self.bin_to_class(ip_address_bin)

        total_hosts = self.get_total_hosts(prefix)
        if not total_hosts:
            return

        details.update({
            'ip': {'address': ip_address, 'bin': ip_address_bin, 'class': ip_class},
            'cidr': cidr,
            'total_hosts': total_hosts
        })

        netmask, netmask_bin = self.get_netmask(prefix)
        if not netmask:
            return

        details.update({
            'netmask': {'address': netmask, 'bin': netmask_bin, 'prefix': prefix},
        })

        wildcard, wildcard_bin = self.get_wilcard(prefix)
        if not wildcard:
            return

        details.update({
            'wildcard': {'address': wildcard, 'bin': wildcard_bin},
        })

        subnet_details = self.get_subnet(ip_address_bin, netmask_bin, wildcard_bin)
        if not isinstance(subnet_details, dict):
            return

        details.update({
            'subnet_details': subnet_details,
        })

        self.details = self.set_details(**details)

        return self.details

    def set_details(self, **kwargs):
        """
        Generate details of IP informations. Also this function is only called from function get_info
        @param kwargs:
        @return: dict
        """
        simple = kwargs.get('simple')
        ip = kwargs.get('ip')
        cidr = kwargs.get('cidr')
        total_hosts = kwargs.get('total_hosts')
        netmask = kwargs.get('netmask')
        wildcard = kwargs.get('wildcard')
        subnet = kwargs.get('subnet_details')

        if not self.validate_details(ip, netmask, wildcard, subnet):
            return

        hostmin = subnet.get('host_min')
        hostmax = subnet.get('host_max')
        broadcast = subnet.get('broadcast')
        network = subnet.get('info').get('address')

        if total_hosts < 256:
            if total_hosts > 2:
                usable_hosts = total_hosts - 2
            else:
                usable_hosts = 1
        else:
            usable_hosts = int((total_hosts/256) * 254)

        results = {
            'source': kwargs.get('source'),
            'ip': ip.get('address') if simple else ip,
            'netmask': netmask.get('address') if simple else netmask,
            'wildcard': wildcard.get('address') if simple else wildcard,
            'network': '%s%s' % (network, cidr) if simple else subnet.get('info'),
            'class': subnet.get('info').get('class'),
            'broadcast': broadcast.get('address') if simple else broadcast,
            'usable_ip_range': '%s - %s' % (hostmin.get('address'), hostmax.get('address')),
            'start_ip': hostmin.get('address'),
            'end_ip': hostmax.get('address'),
            'total_hosts': total_hosts,
            'usable_hosts': usable_hosts,
        }

        if netmask.get('prefix') > 30:
            results['end_ip'] = hostmin.get('address')
            results['usable_ip_range'] = 'N/A'

        if not simple:
            results.update({
                'cidr': cidr,
                'network_cidr': '%s%s' % (network, cidr),
                'host_min': hostmin,
                'host_max': hostmax,
            })

        return results

    def parse_ip(self, val):
        ip_address = None
        prefix = None
        cidr = None
        patern = r'^([0-9]+(?:\.[0-9]+){3})([/\s]+([0-9]+))?$'
        matched = re.search(patern, str(val).strip())
        if matched:
            match_ip = self.clean_ip(matched.group(1).strip())
            match_prefix = matched.group(3)

            valid_ip = self.validate_ip(match_ip)
            if valid_ip:
                ip_address = match_ip

            if match_prefix is not None:
                int_prefix = int(match_prefix.strip())
                prefix = int_prefix if int_prefix <= 32 else 32
            else:
                prefix = 32

            cidr = '/%d' % prefix

        return ip_address, prefix, cidr

    def get_total_hosts(self, prefix):
        valid_prefix = self.validate_prefix(prefix)
        if not valid_prefix:
            return

        total_hosts = 2 ** (32 - valid_prefix)

        return total_hosts

    def get_netmask(self, prefix):
        netmask = ''
        netmask_bin = ''

        valid_prefix = self.validate_prefix(prefix)
        if valid_prefix:
            netmask_bin = ''.join(['1' if i < valid_prefix else '0' for i in range(32)])
            netmask = self.bin_to_ip(netmask_bin)

        return netmask, netmask_bin

    def get_wilcard(self, prefix):
        wildcard = ''
        wildcard_bin = ''

        valid_prefix = self.validate_prefix(prefix)
        if valid_prefix:
            wildcard_bin = ''.join(['0' if i < valid_prefix else '1' for i in range(32)])
            wildcard = self.bin_to_ip(wildcard_bin)

        return wildcard, wildcard_bin

    def get_subnet(self, ip_bin, netmask_bin, wilcard_bin):
        ipb = self.validate_binary(ip_bin)
        nmb = self.validate_binary(netmask_bin)
        wcb = self.validate_binary(wilcard_bin)

        if not ipb or not nmb or not wcb:
            return

        subnet_bin = ''.join(ipb[i] if nmb[i] == '1' else nmb[i] for i in range(32))
        subnet_class = self.bin_to_class(subnet_bin)
        subnet = self.bin_to_ip(subnet_bin)
        if not subnet:
            return

        subnet_min_bin = subnet_bin[:-1] + '1'
        subnet_min = self.bin_to_ip(subnet_min_bin)
        if not subnet_min:
            return

        broadcast_bin = ''.join(subnet_bin[i] if wcb[i] == '0' else wcb[i] for i in range(32))
        broadcast = self.bin_to_ip(broadcast_bin)
        if not broadcast:
            return

        subnet_max_bin = broadcast_bin[:-1] + '0'
        subnet_max = self.bin_to_ip(subnet_max_bin)
        if not subnet_max:
            return

        details = {
            'info': {'address': subnet, 'bin': subnet_bin, 'class': subnet_class},
            'host_min': {'address': subnet_min, 'bin': subnet_min_bin},
            'host_max': {'address': subnet_max, 'bin': subnet_max_bin},
            'broadcast': {'address': broadcast, 'bin': broadcast_bin},
        }

        return details

    def bin_to_ip(self, binary):
        binary = self.validate_binary(binary)
        if not binary:
            return

        ips = [
            sum([2 ** i if int(binary[:8][-i - 1]) else 0 for i in range(7, -1, -1)]),
            sum([2 ** i if int(binary[8:16][-i - 1]) else 0 for i in range(7, -1, -1)]),
            sum([2 ** i if int(binary[16:24][-i - 1]) else 0 for i in range(7, -1, -1)]),
            sum([2 ** i if int(binary[24:32][-i - 1]) else 0 for i in range(7, -1, -1)]),
        ]

        return '.'.join([str(o) for o in ips])

    def bin_to_class(self, binary):
        """
        Convert IP binary to IP Class

        :param binary:
        :return string:
        """
        binary = self.validate_binary(binary)
        if not binary:
            return

        if binary[:1] == '0':
            return 'A'
        elif binary[:2] == '10':
            return 'B'
        elif binary[:3] == '110':
            return 'C'
        elif binary[:4] == '1110':
            return 'D'
        elif binary[:5] == '11110':
            return 'E'
        else:
            return 'Undefined Class'

    def ip_to_bin(self, ip):
        valid_ip = self.validate_ip(ip)
        if not valid_ip:
            return

        return ''.join([
            bin(int(x) + 256)[3:] for x in valid_ip.split('.')
        ])

    def clean_ip(self, ip):
        valid_ip = self.validate_ip(ip)
        if not valid_ip:
            return

        split_ip = re.split(r'\.', valid_ip)

        for i in range(len(split_ip)):
            if split_ip[i] == '0':
                continue
            split_ip[i] = re.sub(r'^0+', '', split_ip[i])

        return '.'.join(split_ip)

    def validate_ip(self, ip):
        ip_address = re.sub('[^0-9.]+', '', str(ip).strip())
        matched = re.match(r'^\b((?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:(?<!\.)\b|\.)){4}$', ip_address)
        if matched is not None:
            return ip_address

        self.logger.warning('Invalid IP Address')

        return

    def validate_prefix(self, prefix):
        if not isinstance(prefix, int):
            number = re.sub(r'\D+', '', str(prefix))
            if number:
                prefix = int(number)

        if not prefix or prefix < 1 or prefix > 32:
            self.logger.info('Ilegal value for prefix')
            return

        return prefix

    def validate_binary(self, binary):
        binary = re.sub(r'[^0-1]+', '', str(binary))
        if len(binary) == 32:
            return binary

        self.logger.error('Invalid value for binary')

        return

    def validate_details(self, ip, netmask, wildcard, subnet):
        if not isinstance(ip, dict):
            self.logger.error('Invalid IP details')
            return False

        if not isinstance(netmask, dict):
            self.logger.error('Invalid Netmask details')
            return False

        if not isinstance(wildcard, dict):
            self.logger.error('Invalid Wildcard details')
            return False

        if not isinstance(subnet, dict):
            self.logger.error('Invalid Subnet details')
            return False

        if not isinstance(subnet.get('info'), dict):
            self.logger.error('Invalid Subnet Info details')

        if not isinstance(subnet.get('host_min'), dict):
            self.logger.error('Invalid Subnet Host Min details')

        if not isinstance(subnet.get('host_max'), dict):
            self.logger.error('Invalid Subnet Host Max details')

        if not isinstance(subnet.get('broadcast'), dict):
            self.logger.error('Invalid Subnet Broadcast details')

        return True
